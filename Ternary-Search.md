如果一个函数f(x)在区间[a,b]上

- 先减后增
- 或者先增后减

那么它在该区间上的最小或者最大值可以用三元搜索[ Ternary Search ](http://apps.topcoder.com/forums/?module=Thread&threadID=506787&start=0&mc=27)找出来。（注意并不一定是凸函数）

	double f(double x)
	{
		return a*x*x+b*x+c;
	}

现假设是第一种情况，即**a>0**要找最小值。

	double ternary_search(double (*f)(double),double l,double r)
	{
		double g,h;
		while(r-l > eps)
		{
			g = l+(r-l)/3.0;
			h = r-(r-l)/3.0;
			if(f(g)<f(h)) //g,h此时不会同时在最小值点M的右侧，那么至少h是在M左侧。
				r=h;
			else //g,h此时不会同时在M的左侧，那么至少g是在M右侧。
				l=g;
		}
		return r;
	}

这种方法中，每次迭代会使查找区间减少1/3。eps从1e-3到1e-11时的平均搜索次数分别
为：

26.906950,32.580880,38.265670,43.939430,49.632970,55.288650,60.978720,66.669620,72.328210

最小二乘拟合后，得到：(array([ 5.67877633,  9.869799  ]), 2) 

从信息论角度来看，精度为1e-k时，最值点有10^k种可能取值，每次迭代使可能的取值个
数减少1/3，n次迭代后，剩下的可能取值为10^k*(2/3)^n。

令其等于1,可得，n=k*ln(10)/ln(3/2) = 5.67887 k，可见跟最小二乘法求出的斜率是一
样的。

----------

先取中点，再取两边的两个中点作为g,h，即相当于四等分点。

	double ternary_search2(double (*f)(double),double l,double r)
	{
		double g=l,h=r;
		double mid;
		while(r-l > eps)
		{
			mid = (g+h)/2;
			g = (l+mid)/2;
			h = (mid+r)/2;
			if(f(g)<f(h))
				a>0?(r=h):(l=g);
			else
				a>0?(l=g):(r=h);
			++S2;
		}
		//printf("S2: %d searchs to find a Minmum/Maxmium.\n",cnt);
		return l;
	}

精度从1e-3到1e-11的平均搜索次数：

67.129870,81.640090,96.200120,110.740070,125.302730,139.791380,154.369250,168.930260,183.433790

最小二乘拟合后，得到：(array([ 14.54126267,  23.49311244]), 2)

ln(10)/ln(4/3)=8.004。*如何寻找合理的解释？*


总之，两次取中点的方法迭代次数一般较直接取等分点的迭代次数多。可能是由于浮点运
算精度造成的。

迭代中，

	g = l+(r-l)/3.0;
	h = r-(r-l)/3.0;

- 这里的1/3.0应该取尽量接近于0.5的浮点数，会大大减少迭代次数。

- 但如果太接近0.5，会使f(g),f(h)太过接近从而增加浮点运算后，对其大小比较出错的可
能。


**记错了，我第一次学到的做法是，先取mid=(l+r)/2，然后midmid=(mid+r)/2，以这两点
做为g,h，也就是每次减少为原来的1/2或者1/4。**
